#!/bin/bash

# calculating phylogenetic distances using megacc

local=$(pwd)

mkdir phylo-distance

cd phylo-distance


cat <<EOF > distance_estimation_pairwise_amino_acid.mao
; Please do not edit this file! If this file is modified, results are unpredictable.
; Instead of modifying this file, simply create a new MEGA Analysis Options file by using MEGA.
[ MEGAinfo ]
ver                                = 11220624-x86_64 Linux             
[ DataSettings ]
datatype                           = snProtein                         
MissingBaseSymbol                  = ?                                 
IdenticalBaseSymbol                = .                                 
GapSymbol                          = -                                 
Labelled Sites                     = All Sites                         
Labels to Include                  =                                   
[ ProcessTypes ]
ppDistEst                          = true                              
ppPairTaxa                         = true                              
[ AnalysisSettings ]
Analysis                           = Distance Estimation               
Scope                              = Pairs of taxa                     
Estimate Variance                  = ====================              
Variance Estimation Method         = Bootstrap method                  
No. of Bootstrap Replications      = 1000                              
Substitution Model                 = ====================              
Substitutions Type                 = Amino acid                        
Model/Method                       = Jones-Taylor-Thornton (JTT) model 
Rates and Patterns                 = ====================              
Rates among Sites                  = Uniform Rates                     
Gamma Parameter                    = Not Applicable                    
Pattern among Lineages             = Same (Homogeneous)                
Data Subset to Use                 = ====================              
Gaps/Missing Data Treatment        = Pairwise deletion                 
Site Coverage Cutoff (%)           = Not Applicable                    
Has Time Limit                     = False                             
Maximum Execution Time             = -1              
EOF

cp ../alignement/all-aligned.fasta .

megacc -a distance_estimation_pairwise_amino_acid.mao -d all-aligned.fasta -f MEGA -o phylo-distance.meg

# export phylo distances in two colum format


gawk '
BEGIN{
  n=0
  in_matrix=0
  cur_i=0
  rowlen=0
  missing_names=0
}

function flush_row(    j){
  if(cur_i==0) return

  # Emitir pares (j < i), row[1..rowlen] corresponde a columnas 1..(i-1)
  for(j=1; j<=rowlen; j++){
    if(names[j]=="" || names[cur_i]==""){
      missing_names++
      # Aun así imprimimos; si prefieres saltar líneas con nombre vacío, pon: continue
    }
    printf "%s\t%s\t%s\n", names[j], names[cur_i], row[j]
  }

  delete row
  rowlen=0
  cur_i=0
}

# Saltar cabeceras
/^(#|!|;)/ { next }
NF==0 { next }

# ---------- 1) Leer nombres ----------
# Formato: [ 1] #Nombre  o  [10] #Nombre
# Usamos match sobre la línea completa para capturar índice y nombre.
(in_matrix==0) {
  if (match($0, /^\[\s*([0-9]+)\]\s*(.+)$/, m)) {
    idx = m[1] + 0
    name = m[2]
    sub(/^\s+/, "", name)
    sub(/^#/, "", name)  # quita el #; comenta si lo quieres conservar
    names[idx] = name
    if (idx > n) n = idx
    next
  }
}

# Detectar inicio de la matriz: línea tipo "[ 1 2 3 ... ]"
/^\[\s*1(\s+2)(\s+3)/ {
  in_matrix=1
  next
}

# Si no estamos en matriz, ignorar
in_matrix==0 { next }

# ---------- 2) Filas de la matriz ----------
# Nueva fila: empieza por [i]
{
  # Si la línea empieza por "[ i]" es una fila nueva
  if (match($0, /^\[\s*([0-9]+)\]\s*(.*)$/, r)) {
    flush_row()

    cur_i = r[1] + 0
    line  = r[2]

    # Cortar desde el primer "[": ahí empiezan los S.E. entre corchetes
    sub(/\[.*/, "", line)

    gsub(/[[:space:]]+/, " ", line)
    sub(/^ /, "", line); sub(/ $/, "", line)

    if (length(line) > 0) {
      split(line, a, " ")
      for (k=1; k<=length(a); k++) {
        if (a[k] ~ /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/) {
          row[++rowlen] = a[k]
        }
      }
    }
    next
  }

  # Línea de continuación: puede traer más distancias antes de los S.E.
  if (cur_i != 0) {
    line = $0
    sub(/\[.*/, "", line)

    gsub(/[[:space:]]+/, " ", line)
    sub(/^ /, "", line); sub(/ $/, "", line)

    if (length(line) > 0) {
      split(line, a, " ")
      for (k=1; k<=length(a); k++) {
        if (a[k] ~ /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/) {
          row[++rowlen] = a[k]
        }
      }
    }
  }
}

END{
  flush_row()

  # Aviso si faltan nombres (se escribe a stderr)
  if (missing_names > 0) {
    print "AVISO: hubo " missing_names " filas con nombre vacío; revisa el parseo de nombres." > "/dev/stderr"
  }
}
'  < phylo-distance.meg > phylo-distance.dat



cd $local
